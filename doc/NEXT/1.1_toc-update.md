Nice! Det ser godt ud — du har allerede **gutter + cirkler** på linje med kortene. Her er en kort, konkret vej fra “CSS-timeline” → **gitgraph.js med farvede lanes og links**, mens alt forbliver i samme “tabel” (grid).

# Plan (kort)

1. **Behold dit grid**

   * Fortsæt med 2 kolonner: `[gutter, content]`.
   * I gutter-cellen for kapitlet lægger du **én** container til gitgraph:

     ```html
     <div class="relative w-[72px]">
       <div id="graph-chapter-{chapter.id}" class="absolute inset-0"></div>
     </div>
     ```
   * Content-kolonnen er dine scene-cards (uændret).

2. **Installer & init**

   ```bash
   pnpm add @gitgraph/js
   ```

   ```ts
   import { createGitgraph } from "@gitgraph/js";
   const el = document.getElementById(`graph-chapter-${chapter.id}`);
   const gitgraph = createGitgraph(el, {
     template: { colors: ["#60a5fa","#34d399","#a78bfa","#f59e0b","#f87171","#22d3ee"] },
   });
   ```

3. **Row-alignment**
   Brug samme rækkehøjde som kortene (fx `rowHeight = 64`). Y for scene i listen:

   ```ts
   const y = i * rowHeight + rowHeight / 2; // i = scene-rækkeindeks
   ```

   (Hvis kort har variabel højde, kan du måle dem med `getBoundingClientRect()` og lave en kumulativ Y.)

4. **Simpel lane-allocator**
   Vi kører **en lane pr. udgående “tråd”** og farver lane’en. Det er “git-agtigt”, nemt at overskue.

   ```ts
   type Scene = { id: string; title: string };
   type Link  = { from: string; to: string };

   // Returnerer branch pr. lane og commitHandle pr. scene
   function buildGraph(gitgraph, scenes: Scene[], links: Link[], rowHeight=64) {
     const laneFor: Record<string, number> = {};
     const branchForLane: any[] = [];
     const commitOf: Record<string, any> = {};
     let nextLane = 0;

     // 1) Commit alle scener i rækkefølge
     scenes.forEach((s, i) => {
       if (laneFor[s.id] == null) {
         laneFor[s.id] = nextLane++;
         branchForLane[laneFor[s.id]] = gitgraph.branch({ name: `lane-${laneFor[s.id]}` });
       }
       const lane = laneFor[s.id];
       const y = i * rowHeight + rowHeight / 2;
       commitOf[s.id] = branchForLane[lane].commit({ subject: s.title, tag: s.id, renderY: y });
     });

     // 2) Links: ny lane fra A, merge til lane(B)
     links.forEach((lnk) => {
       const aLane = laneFor[lnk.from];
       const bLane = laneFor[lnk.to] ?? (laneFor[lnk.to] = nextLane++, branchForLane[laneFor[lnk.to]] = gitgraph.branch({ name:`lane-${laneFor[lnk.to]}` }), laneFor[lnk.to]);
       const tmp = branchForLane[aLane].branch({ name: `from-${lnk.from}-to-${lnk.to}` });
       tmp.commit();                // lille “knop” fra A
       tmp.merge(branchForLane[bLane]); // forbind til B’s lane (farver holdes pr. lane)
     });
   }
   ```

5. **Knyt til din TOC**

   * Kald `buildGraph(gitgraph, chapterScenes, chapterLinks, rowHeight)` **efter** at listen er rendret, så højder/kalkuleret Y passer.
   * Hver **ny lane** får automatisk **ny farve** via `template.colors`.

6. **UX-detaljer**

   * Hover på et scene-kort → find `tag: scene.id` i gitgraph og highlight den lane (tilføj CSS-klasse på containeren).
   * Klik på node → scroll/fokusér kortet i højre kolonne.

---

## Hvad du får med det samme

* Cirkler (nodes) ligger **i samme række** som scene-kortene (fordi y = række-center).
* **Flere lodrette baner** oprettes automatisk, hver med **egen farve**.
* Links tegnes som **små forgreninger** fra `from`-scene til `to`-scene’s lane (git-look).

Vil du have, at jeg pakker ovenstående i en lille `TocGraphGitgraph.svelte` (med `rowHeight` prop og et minimalt theme), så din AI-coder kan drop-in montere den pr. kapitel?
